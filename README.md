Heroes Battle - учебная реализация алгоритмов игры
-----------------------------------

В репозитории находятся 4 класса реализующие логику `com.battle.heroes.army.programs`.
В каталоге /out расположен собранный odf.jar.

```
src/main/java/programs/
 ├── GeneratePresetImpl.java
 ├── SuitableForAttackUnitsFinderImpl.java
 ├── UnitTargetPathFinderImpl.java
 └── SimulateBattleImpl.java
```

Ниже — обзор решения, подробный расчёт алгоритмической сложности каждого
класса и краткое описание тестов.

---

1. GeneratePresetImpl
---------------------

Задача  
Создать «боеспособный» стартовый пресет-армии, не превысив бюджет
`maxPoints`, и расставить бойцов на поле.

Этапы алгоритма и их сложность

| № | этап | сложность | доказательство |
|---|------|-----------|----------------|
|1|Фильтрация прототипов: берём первый экземпляр каждого типа|O(P)|один линейный проход по входному списку `prototypes` (P ≤ 4·11).|
|2|Формирование списка кандидатов (до 11 копий каждого типа)|O(T·MAX) = O(N)|T — типов, MAX = 11, N = T·MAX ≤ 44.|
|3|Сортировка кандидатов по «выгоде»|O(N log N)|стандартная Java `List.sort`.|
|4|Жадный выбор до исчерпания бюджета|O(N²)|В худшем случае каждый из N элементов просматривается при каждой из ≤ N покупок. N = 44, поэтому этап занимает < 2 000 операций.|
|5|Расстановка по координатам|O(K)|K — итоговое число выбранных юнитов (≤ N).|

Итоговая асимптота:  
`O(N²)` (сортировка поглощена, так как N² > N log N при N≤44).  
Это равно или **лучше** требования лабораторной (`≤ O(N²)`).

2. SuitableForAttackUnitsFinderImpl
-----------------------------------

Задача  
Вернуть юнитов, которые смогут сделать шаг вперёд и атаковать.

Алгоритм

1. Одна линейная итерация по матрице `unitsByRow`  
   • собираем список живых юнитов `alive`;  
   • заносим все занятые клетки в `HashSet occupied`.

2. Для каждого живого юнита проверяем клетку (x, y + dy).

Сложность

```
Шаг 1:  O(U)   // U – количество живых юнитов армии
Шаг 2:  O(U)
-----------------
Итого : O(U)
Память: O(U)  // HashSet occupied
```

Это **точно совпадает** с указанной в документации сложностью.

3. UnitTargetPathFinderImpl
---------------------------

Задача  
Найти кратчайший путь 8-ходовым BFS на поле 27 × 21.

Стадии

|этап|операция|сложность|
|----|--------|---------|
|1|Построение булевой карты `blocked`|O(U)   (U ≤ 567)|
|2|BFS (просмотр ≤ 27·21 вершин, 8 рёбер каждая)|O(W·H) = O(567)|
|3|Восстановление пути|O(L) (L ≤ 567)|

Верхняя оценка: `O(U + W·H)`, но и U, и W·H — константы < 600, поэтому
алгоритм работает за фиксированное время; память `O(W·H)`.

Требование лабораторной (не хуже O(W·H)) выполняется.

4. SimulateBattleImpl
---------------------

Задача  
Пошагово симулировать бой двух армий до уничтожения одной из сторон.

Пусть N — суммарное число живых юнитов в начале раунда,  
R — полное число раундов до победы.

|этап|операция|сложность за раунд|
|----|--------|-----------------|
|1|Формирование очереди|O(N)|
|2|Сортировка очереди по `baseAttack`|O(N log N)|
|3|Последовательные ходы юнитов|O(N)|

Итого за раунд: `O(N log N)`  
За весь бой: `O(R · N log N)` — совпадает с оценкой, указанной в коде и
допустимой по заданию.

---

Тесты
-----

Модульные тесты лежат в `src/test/java/programs`.

| Класс-тест | Проверяет |
|------------|-----------|
|`GeneratePresetImplTest`|соблюдение бюджета, отсутствие «пустых» координатных дыр.|
|`UnitTargetPathFinderImplTest`|корректный кратчайший путь и отсутствие пути в глухом тупике.|
|`SuitableForAttackUnitsFinderImplTest`|верный список «готовых к атаке» юнитов.|
|`SimulateBattleImplTest`|что бой завершается и побеждает ожидаемая армия.|

Для быстрого локального прогона достаточно команд

```bash
./gradlew test        # все JUnit-тесты
```

---

Содержимое решения
------------------

Файл | Назначение | Ключевые идеи
-----|------------|--------------
`GeneratePresetImpl.java` | Генерация армии-пресета | Жадный выбор из ≤ 44 кандидатов + строй «3 колонны».
`SuitableForAttackUnitsFinderImpl.java` | Поиск юнитов, готовых атаковать | HashSet для проверки занятости соседней клетки → `O(U)`.
`UnitTargetPathFinderImpl.java` | BFS-поиск пути | 27 × 21 решётка, обход ≤ 600 клеток, память `O(WH)`.
`SimulateBattleImpl.java` | Пошаговая симуляция боя | Каждый раунд пере-сортирует очередь по `baseAttack`.

Все алгоритмы удовлетворяют или превосходят требования по скорости и 
памяти, изложенных в задании.